# 2.4

## 练习 2.4 下面是序对的另一种过程性表示方式。请针对这一表示验证，对于任意的x和y，(car (cons x y)) 都将产生出x。

```eval-scheme
(define (cons x y)
  (lambda (m) (m x y)))

(define (car z)
  (z (lambda (p q) p)))
```

### 先体验一下

```eval-scheme
(cons 1 2)
```

```eval-scheme
(car (cons 1 2))
```

### 证明

(cons x y) 返回一个函数，该函数接受一个操作，并返回该操作应用于 x 和 y 上的结果。

(car z) 是另一个函数，它接受一个操作，并将该操作应用于另一个总是返回第一个参数的操作。

(car (cons x y)) 是 (car z) 的具体化，这个具体的函数接受到的操作是 (cons x y)，于是 (car z) 的执行将应用 (cons x y)，应用 (cons ) 时，cons 就接收到了那个总是返回第一个参数的操作作为参数。于是，cons 就应用这个总是返回第一个参数的操作，并且将 x 和 y 作为参数传入，这个总是返回第一个参数的操作接收到的第一个参数就是 x，即结果就是 x。

展开表示是这样的：

```
(car (cons x y))， 这里 z = (cons x y)
(car z)， 展开（执行）
(z (lambda (p q) p))， 参数 (lambda (p q) p) 传给了 z， 要执行 z，先展开
((cons x y) (lambda (p q) p))， 先执行 (cons x y)，要执行，先展开
((lambda (m) (m x y)) (lambda (p q ) p))， 要执行第一个 lambda，第一个 lambda 需要一个参数 m。可以看出这个 m 在执行时就是第二个 lambda，把第二个 lambda 代入到 m
((lambda ((lambda (p q) p)) ((lambda (p q) p) x y)))，执行第一个 lambda，即去掉 lambda 和参数，运行 body
((lambda (p q) p) x y)， 即最后一个操作是一个 lambda，它的参数是x 和 y，代入并运行最后一个 lambda
x， 即最后一个操作的结果
```