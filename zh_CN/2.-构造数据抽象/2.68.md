# 2.68

## 练习 2.68 过程encode以一个消息和一棵树为参数，产生出被编码消息所对应的二进制位的表：

```eval-scheme
(define (encode message tree)
    (if (null? message)
        '()
        (append 
            (encode-symbol (car message) tree)
            (encode (cdr message) tree)
        )
    )
)
```

其中的encode-symbol是需要你写的过程，它能根据给定的树产生出给定符号的二进制位表。你所设计的encode-symbol在遇到未出现在树中的符号时应报告错误。请用在练习2.67中得到的结果检查所实现的过程，工作中用同样一棵树，看看得到的结果是不是原来那个消息。

--- 

```eval-scheme
(define (encode-symbol char tree)
    (let 
        (
            (left (left-branch tree))
            (right (right-branch tree))
        )
        (if (leaf? left) 
            (if (eq? (symbol-leaf left) char) 
                (list '0)
                (if (leaf? right)
                    (if (eq? (symbol-leaf right) char)
                        (list '1)
                        'error-not-found-in-tree
                    )
                    (let
                        (
                            (right-res (encode-symbol char right))
                        )
                        (if 
                            (eq? 
                                right-res 
                                'error-not-found-in-tree
                            )
                            'error-not-found-in-tree
                            (append (list '1) (encode-symbol char right))
                        )
                    )
                )
            )
            (
                (let 
                    (
                        (left-res (encode-symbol char left))
                    )
                    (if (eq? (left-res 'error-not-found-in-tree))
                        (encode-symbol char right)
                        left-res
                    )
                )
            )
        )
    )
)


```

decode 的代码如下：

```eval-scheme
(define (decode bits tree)
    (define (decode-1 bits current-branch)
        (if (null? bits)
            '()
            (let 
                (
                    (next-branch
                        (choose-branch 
                            (car bits)
                            current-branch
                        )
                    )
                )

                (if (leaf? next-branch)
                    (cons 
                        (symbol-leaf next-branch) 
                        (decode-1 (cdr bits) tree)
                    )
                    (decode-1 (cdr bits) next-branch)
                )
            )
        )
    )

    (decode-1 bits tree)
)

(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))

(define (choose-branch bit branch)
    (cond 
        ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else
            (error "bad bit -- CHOOSE-BRANCH" bit)
        )
    )
)

(define (make-leaf symbol weight)
    (list 'leaf symbol weight)
)

(define (leaf? object) (eq? (car object) 'leaf))

(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))


(define (make-code-tree left right)
    (list 
        left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))
    )
)

(define (symbols tree)
    (if (leaf? tree)
    (list (symbol-leaf tree))
    (caddr tree))
)

(define (weight tree)
    (if 
        (leaf? tree)
        (weight-leaf tree)
        (cadddr tree)
    )
)

(define sample-tree
    (make-code-tree 
        (make-leaf 'A 4)
        (make-code-tree 
            (make-leaf 'B 2)
            (make-code-tree
                (make-leaf 'D 1)
                (make-leaf 'C 1)
            )
        )
    )
)

(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))

(decode sample-message sample-tree)
```

```eval-scheme

(define sample-tree
    (make-code-tree 
        (make-leaf 'A 4)
        (make-code-tree 
            (make-leaf 'B 2)
            (make-code-tree
                (make-leaf 'D 1)
                (make-leaf 'C 1)
            )
        )
    )
)


(encode-symbol 'A sample-tree)
```

```eval-scheme
(encode (list 'A 'D 'A 'B 'B 'C 'A) sample-tree)
```

结果和 sample-message 一致！