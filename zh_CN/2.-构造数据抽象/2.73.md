# 2.73

## 练习 2.73 2.3.2节描述了一个执行符号求导的程序：

```
(define (deriv exp var)
    (cond ((number? exp) 0)
        ((variable? exp) (if (same-varialbe? exp var) 1 0))
        ((sum? exp)
            (make-sum (deriv (addend exp) var)
                    (deriv (augend exp) var)))
            ((product? exp)
            
            (make-sum
                (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
                (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
    <更多规则可以加在这里>
    (else (error "unknown expression type -- DERIV" exp))))
```

可以认为，这个程序是在执行一种基于被求导表达式类型的分派工作。在这里，数据的“类型标志”就是代数运算符（例如+），需要执行的操作是deriv。我们也可以将这一程序变换到数据导向的风格，将基本求导过程重新写成：

```
(define (deriv exp var)
    (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        (else ((get 'deriv (operator exp)) (operands exp) var))))

(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
```

a）请解释上面究竟做了些什么。为什么我们无法将相近的谓词number?和same-variable?也加入数据导向分派中？

b）请写出针对和式与积式的求导过程，并把它们安装到表格里，以便上面程序使用所需要的辅助性代码。

c）请选择一些你希望包括的求导规则，例如对乘幂（练习2.56）求导等等，并将它们安装到这一数据导向的系统里。

d）在这一简单的代数运算中，表达式的类型就是构造起它们来的代数运算符。假定我们想以另一种相反的方式做索引，使得deriv里完成分派的代码行像下面这样：

```
((get (operator exp) 'deriv) (operands exp) var)
```

求导系统里还需要做哪些相应的改动？
----

a) 上面将对不同类型的导数求法放在一张表里，通过查表法来进行计算。